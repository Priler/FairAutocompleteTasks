-- Fair Autocomplete - Core Script
-- autocompletes tasks only when player/companions actually did the work

printf("[FA] Core script loading...")

-- ### MODULE REFERENCES

local function get_mcm_config(category, key)
    if fair_autocomplete_mcm and fair_autocomplete_mcm.get_config then
        return fair_autocomplete_mcm.get_config(category, key)
    end
    local defaults = {
        enable = true,
        enable_autocomplete = true,
        pda_check = true,
        require_player_kill = true,
        companion_kills_count = true,
        count_assists = true,
        max_kill_distance = 0,
        require_same_level = true,
        cancel_if_stolen = true,
        check_interval = 2.0,
        -- Task types
        assault = true,
        bounty = true,
        mutant_hunt = true,
        spring_clean = true,
        defense = true,
        hostage = false,
        spy_extract = false,
        fate = false,
        scripted = false,
        retrieve = false,
        measurements = false,
        scanner = false,
        snitch = false,
        destroy_btrs = true,
        research_hunt = false,
        recover_tracker = false,
        -- Kill requirement (1=one, 2=half, 3=all)
        kill_requirement = 1,
        -- Rewards
        compensate_item_rewards = true,
        compensation_coefficient = 0.4,
        -- UI
        show_target_info = true,
        show_stolen_message = true,
        -- Lists
        whitelist = "esc_2_12_stalker_fanat_task_3:0",
        blacklist = "esc_2_12_stalker_wolf_task_3",
        -- Debug
        debug = false,
    }
    return defaults[key]
end

-- ### HARDCODED BLACKLIST

local HARDCODED_BLACKLIST = {
    ["task_fanat_training_1"] = true,
    ["task_fanat_training_2"] = true,
    ["task_fanat_training_3"] = true,
    ["devushka_1_give"] = true,
    ["devushka_3_give"] = true,
    ["devushka_4_give"] = true,
    ["devushka_5_give"] = true,
    ["devushka_help_1_give"] = true,
    ["devushka_help_2_give"] = true,
    ["hide_from_surge"] = true,
    ["hide_from_psi_storm"] = true,
    ["yan_stalker_sakharov_psi_helmet_upgrade"] = true,
    ["turn_off_brain_machine"] = true,
    ["turn_off_brain_scorcher"] = true,
    ["barrier_defense_monolith"] = true,
    ["barrier_defense_zombie"] = true,
    ["mar_base_owl_stalker_trader_task_1"] = true,
    ["mar_base_owl_stalker_trader_task_2"] = true,
}

-- ### STATE

local _mod_ready = false
_task_cache = {}
_task_cache_count = 0  -- Track cache size
local _registered_tasks = {}
local _recently_processed = {}  -- Tasks recently completed/cancelled (prevent duplicates)
_task_compensation_prices = {}  -- Cache for item reward compensation (GLOBAL for task_callback)
_tasks_being_autocompleted = {}

-- module cache
local _utils = nil
local function get_utils()
    if not _utils then
        _utils = fair_autocomplete_utils
    end
    return _utils
end

local _kill_tracker = nil
local function get_kill_tracker()
    if not _kill_tracker then
        _kill_tracker = fair_autocomplete_kill_tracker
    end
    return _kill_tracker
end

-- cleanup old task cache entries
local function cleanup_task_cache()
    -- soft eviction: only wipe if significantly oversized
    if _task_cache_count > 500 then
        _task_cache = {}
        _task_cache_count = 0
    end
    
    -- cleanup old recently_processed entries (older than 60 seconds)
    local current_time = os.time()
    for task_id, processed_time in pairs(_recently_processed) do
        if current_time - processed_time > 60 then
            _recently_processed[task_id] = nil
        end
    end
end

-- ### TASK FUNCTOR MAPPING

local TASK_FUNCTOR_MAP = {
    -- kill tasks (require validation)
    ["assault_task_target_functor"] = { key = "assault", type = "assault" },
    ["task_targets_lostzone_all"] = { key = "assault", type = "assault" },
    ["general_bounty_task"] = { key = "bounty", type = "bounty" },
    ["top_10_task_target_functor"] = { key = "snitch", type = "bounty" },
    ["mutants_in_map_target"] = { key = "spring_clean", type = "mutant_hunt" },
    ["yan_ecolog_semenov_task_target_1"] = { key = "research_hunt", type = "mutant_hunt" },
    ["recover_mutant_data_target"] = { key = "recover_tracker", type = "mutant_hunt" },
    ["hunter_kill_target"] = { key = "mutant_hunt", type = "mutant_hunt" },
    ["veh_destroy_tf"] = { key = "destroy_btrs", type = "assault" },
    
    -- defense tasks
    ["gd_task_target_functor"] = { key = "defense", type = "defense" },
    
    -- non-kill tasks
    ["simulation_task_target"] = { key = "hostage", type = "hostage" },
    ["spy_task_target_functor"] = { key = "spy_extract", type = "spy" },
    ["general_fate"] = { key = "fate", type = "fate" },
    ["recover_item_on_corpse_target_functor"] = { key = "scripted", type = "scripted" },
    ["drx_sl_quest_item_task_target"] = { key = "retrieve", type = "retrieve" },
    ["general_measure"] = { key = "measurements", type = "measurements" },
    ["anomaly_scanner_task_target"] = { key = "scanner", type = "scanner" },
}

-- task IDs that should be treated as a certain type (overrides functor detection)
local TASK_ID_OVERRIDES = {
}

-- task ID prefixes that should be treated as a certain type
local TASK_PREFIX_OVERRIDES = {
    ["bar_dolg_general_petrenko_stalker_task_rioc_"] = { key = "fate", type = "fate" },
}

-- tasks that start with these prefixes are mutant hunts
local MUTANT_HUNT_TASK_PREFIXES = {
    "hunter_",
}

local KILL_VALIDATION_TYPES = {
    ["assault"] = true,
    ["bounty"] = true,
    ["mutant_hunt"] = true,
    ["defense"] = true,
}

-- check if task matches any prefix override
local function get_prefix_override(task_id)
    if not task_id then return nil end
    for prefix, override in pairs(TASK_PREFIX_OVERRIDES) do
        if task_id:sub(1, #prefix) == prefix then
            return override
        end
    end
    return nil
end

-- ### HELPER FUNCTIONS

local function is_task_type_enabled(target_functor, task_id)
    -- check task ID overrides first
    if task_id and TASK_ID_OVERRIDES[task_id] then
        local override = TASK_ID_OVERRIDES[task_id]
        return get_mcm_config(nil, override.key)
    end
    
    -- check prefix overrides
    local prefix_override = get_prefix_override(task_id)
    if prefix_override then
        return get_mcm_config(nil, prefix_override.key)
    end
    
    local info = TASK_FUNCTOR_MAP[target_functor]
    if not info then return false end
    return get_mcm_config(nil, info.key)
end

local function get_task_type(target_functor, task_id)
    -- check task ID overrides first
    if task_id and TASK_ID_OVERRIDES[task_id] then
        return TASK_ID_OVERRIDES[task_id].type
    end
    
    -- check prefix overrides
    local prefix_override = get_prefix_override(task_id)
    if prefix_override then
        return prefix_override.type
    end
    
    -- check if task_id matches mutant hunt prefixes
    if task_id then
        for _, prefix in ipairs(MUTANT_HUNT_TASK_PREFIXES) do
            if task_id:sub(1, #prefix) == prefix then
                return "mutant_hunt"
            end
        end
    end
    
    local info = TASK_FUNCTOR_MAP[target_functor]
    return info and info.type or "unknown"
end

-- random stolen task messages
local STOLEN_MESSAGE_IDS = {
    "st_fa_task_stolen_msg_1",
    "st_fa_task_stolen_msg_2",
    "st_fa_task_stolen_msg_3",
}

local function show_stolen_message(task_id, task_giver_id)
    if not db.actor then return end
    
    if not get_mcm_config(nil, "show_stolen_message") then return end
    
    local msg_id = STOLEN_MESSAGE_IDS[math.random(#STOLEN_MESSAGE_IDS)]
    local msg = game.translate_string(msg_id)
    if not msg or msg == msg_id then
        msg = "Someone else completed your task target. Task cancelled without penalty."
    end
    
    local header = "PDA"
    local icon = "ui_inGame2_PD_Otmena_zadaniya"
    
    if task_giver_id then
        local se_obj = alife_object(task_giver_id)
        if se_obj then
            local char_name = se_obj:character_name()
            if char_name and char_name ~= "" then
                header = char_name
            end
            local char_icon = se_obj:character_icon()
            if char_icon and char_icon ~= "" then
                icon = char_icon
            end
        end
    end
    
    msg = "%c[default]" .. msg
    
    if xr_sound and xr_sound.set_sound_play then
        xr_sound.set_sound_play(AC_ID, "pda_tips")
    end
    
    db.actor:give_game_news(header, msg, icon, 0, 5000)
end

-- show PDA message when task is autocompleted
local function show_completion_message(task_id, task_giver_id)
    if not db.actor then return end
    
    local tsk = _task_cache[task_id]
    local finish_message = tsk and tsk.task_complete_descr
    
    if not finish_message then return end
    
    local sender_obj = alife_object(task_giver_id)
    if not sender_obj then
        printf("[FA] Couldn't send completion message: task giver is nil")
        return
    end
    
    -- handle squad task givers
    if sender_obj:clsid() == clsid.online_offline_group_s then
        local commander_obj = alife_object(sender_obj:commander_id())
        if not commander_obj then
            printf("[FA] Couldn't send completion message: task giver is an invalid squad")
            return
        end
        sender_obj = commander_obj
    end
    
    if not sender_obj.character_name or not sender_obj.community or not sender_obj.character_icon then
        printf("[FA] Couldn't send completion message: task giver is invalid")
        return
    end
    
    if xr_sound and xr_sound.set_sound_play then
        xr_sound.set_sound_play(AC_ID, "pda_tips")
    end
    
    local message_title = string.format("%s, %s", 
        sender_obj:character_name(), 
        game.translate_string(sender_obj:community()))
    
    local icon = sender_obj:character_icon()
    
    db.actor:give_game_news(message_title, game.translate_string(finish_message), icon, 0, 5000)
end

-- ### ITEM COMPENSATION

function calculate_task_compensation(reward_table)
    if not reward_table then return nil end
    
    local min_reward, max_reward = 0, 0
    local cleaned_rewards = {}
    
    local utils = get_utils()
    local sell_discount = 1
    if utils and utils.get_generic_sell_discount then
        local success, result = pcall(utils.get_generic_sell_discount)
        if success and result then
            sell_discount = result
        end
    end
    
    local coefficient = get_mcm_config(nil, "compensation_coefficient") or 0.4
    
    for _, attrs in pairs(reward_table) do
        if not attrs or not attrs[1] then goto continue end
        
        local attr_name, attr_args = attrs[1], attrs[3]
        
        if attr_name == "reward_money" then
            local money = tonumber(attr_args[1]) or 0
            min_reward = min_reward + money
            max_reward = max_reward + money
            
        elseif attr_name == "reward_random_money" then
            local money_min = tonumber(attr_args[1]) or 0
            local money_max = tonumber(attr_args[2]) or 0
            min_reward = min_reward + money_min
            max_reward = max_reward + money_max
            
        elseif attr_name == "reward_item" then
            local cost = 0
            if utils and utils.get_base_cost then
                local success, result = pcall(utils.get_base_cost, attr_args[1])
                if success and result then cost = result end
            elseif ini_sys and ini_sys.r_float_ex then
                cost = ini_sys:r_float_ex(attr_args[1], "cost") or 0
            end
            local price = cost * sell_discount * coefficient
            min_reward = min_reward + price
            max_reward = max_reward + price
            
        elseif attr_name == "reward_random_item" then
            local low, high = math.huge, -math.huge
            for _, item in pairs(attr_args) do
                local cost = 0
                if utils and utils.get_base_cost then
                    local success, result = pcall(utils.get_base_cost, item)
                    if success and result then cost = result end
                elseif ini_sys and ini_sys.r_float_ex then
                    cost = ini_sys:r_float_ex(item, "cost") or 0
                end
                local price = cost * sell_discount * coefficient
                if price > high then high = price end
                if price < low then low = price end
            end
            if low ~= math.huge then min_reward = min_reward + low end
            if high ~= -math.huge then max_reward = max_reward + high end
            
        else
            -- Keep other reward types (goodwill, stash, etc.)
            table.insert(cleaned_rewards, attrs)
        end
        
        ::continue::
    end
    
    if min_reward > 0 or max_reward > 0 then
        table.insert(cleaned_rewards, {
            "reward_random_money", 3, { min_reward, max_reward }
        })
    end
    
    return { rewards = cleaned_rewards, min = min_reward, max = max_reward }
end

-- cache compensation prices during task registration
local function cache_compensation_prices(task_id)
    if _task_compensation_prices[task_id] then return end
    
    local tm = task_manager.get_task_manager()
    if not tm then return end
    
    local tm_info = tm.task_info[task_id]
    if not tm_info then return end
    
    if tm_info.on_complete and tm_info.on_complete[1] and tm_info.on_complete[1][3] then
        _task_compensation_prices[task_id] = calculate_task_compensation(tm_info.on_complete[1][3])
        if _task_compensation_prices[task_id] then
            printf("[FA] Cached compensation for task %s: %s-%s RU", task_id, 
                _task_compensation_prices[task_id].min or 0, 
                _task_compensation_prices[task_id].max or 0)
        end
    end
end

-- ### TASK REGISTRATION

local function register_task(task_id)
    local current_time = os.time()
    
    -- update timestamp for re-taken tasks
    if _registered_tasks[task_id] then
        _registered_tasks[task_id].registered_time = current_time
        printf("[FA] Task re-registered (re-taken): %s - updated timestamp", task_id)
        return
    end
    
    local tsk = _task_cache[task_id]
    if not tsk then
        local parsed = utils_data.parse_ini_section_to_array(task_manager.task_ini, task_id)
        if parsed then
            _task_cache[task_id] = parsed
            _task_cache_count = _task_cache_count + 1
            tsk = parsed
        end
    end
    
    if not tsk or not tsk.target_functor then return end
    
    cache_compensation_prices(task_id)
    
    local task_type = get_task_type(tsk.target_functor, task_id)
    local var = load_var(db.actor, task_id)
    
    local reg_data = {
        type = task_type,
        target_id = nil,
        smart_terrain = nil,
        registered_time = current_time,
    }
    
    if task_type == "bounty" then
        if axr_task_manager and axr_task_manager.bounties_by_id then
            local raw_id = axr_task_manager.bounties_by_id[task_id]
            reg_data.target_id = tonumber(raw_id) or raw_id
        end
        if not reg_data.target_id and var then
            reg_data.target_id = tonumber(var.target_id) or var.target_id
        end
    elseif task_type == "assault" or task_type == "defense" then
        if var and var.smart_id then
            local smart_obj = alife_object(var.smart_id)
            if smart_obj then
                reg_data.smart_terrain = smart_obj:name()
            end
        end
    elseif task_type == "mutant_hunt" then
        -- mutant hunts can have either a specific target or a location
        if var then
            if var.target_id then
                reg_data.target_id = tonumber(var.target_id) or var.target_id
                local se_obj = alife_object(var.target_id)
                if se_obj then
                    reg_data.mutant_section = se_obj:section_name()
                end
            end
            
            -- squad's player_id contains the monster type
            if var.squad_id and not reg_data.mutant_section then
                local squad = alife_object(var.squad_id)
                if squad then
                    if squad.player_id then
                        if is_squad_monster and is_squad_monster[squad.player_id] then
                            reg_data.mutant_section = squad.player_id
                            printf("[FA] Got mutant section from squad.player_id: %s", tostring(squad.player_id))
                        end
                    end
                    
                    -- fallback: get section from first squad member
                    if not reg_data.mutant_section and squad.squad_members then
                        for member in squad:squad_members() do
                            local se_member = member.object or (member.id and alife_object(member.id))
                            if se_member then
                                local sec = se_member:section_name()
                                if sec then
                                    local base_type = string.match(sec, "^([^_]+)")
                                    if base_type and is_squad_monster and is_squad_monster[base_type] then
                                        reg_data.mutant_section = base_type
                                    else
                                        reg_data.mutant_section = sec
                                    end
                                    printf("[FA] Got mutant section from squad member: %s", tostring(reg_data.mutant_section))
                                    break
                                end
                            end
                        end
                    end
                end
            end
            
            -- try to get mutant type from task variables
            if not reg_data.mutant_section then
                reg_data.mutant_section = var.mutant_type or var.monster_type or var.section 
                    or var.monster or var.target_section or var.enemy_section
                    or var.mutant or var.creature or var.creature_type
            end
            
            -- try smart terrain from multiple fields
            if var.smart_id then
                local smart_obj = alife_object(var.smart_id)
                if smart_obj then
                    reg_data.smart_terrain = smart_obj:name()
                end
            elseif var.smart then
                if type(var.smart) == "string" then
                    reg_data.smart_terrain = var.smart
                elseif type(var.smart) == "number" then
                    local smart_obj = alife_object(var.smart)
                    if smart_obj then
                        reg_data.smart_terrain = smart_obj:name()
                    end
                end
            end
            
            -- debug: dump var keys if we couldn't find section
            if not reg_data.mutant_section then
                local var_keys = {}
                for k, v in pairs(var) do
                    table.insert(var_keys, tostring(k) .. "=" .. tostring(v))
                end
                printf("[FA] mutant_hunt var dump for %s: %s", task_id, table.concat(var_keys, ", "))
            end
        end
        
        -- try to get mutant section from task definition
        if not reg_data.mutant_section then
            local tsk = _task_cache[task_id]
            if tsk then
                reg_data.mutant_section = tsk.mutant_type or tsk.monster_type 
                    or tsk.target_section or tsk.monster
            end
        end
        
        printf("[FA] Registered mutant_hunt task: %s section=%s smart=%s", task_id, tostring(reg_data.mutant_section), tostring(reg_data.smart_terrain))
    end
    
    _registered_tasks[task_id] = reg_data
end

local function unregister_task(task_id)
    _registered_tasks[task_id] = nil
    _task_compensation_prices[task_id] = nil
    
    -- evict from task cache to keep memory bounded
    if _task_cache[task_id] then
        _task_cache[task_id] = nil
        _task_cache_count = math.max(0, _task_cache_count - 1)
    end
end

-- ### KILL VALIDATION

-- safely get time as number
local function get_time_as_number(time_value)
    if not time_value then return 0 end
    if type(time_value) == "number" then return time_value end
    return 0
end

-- get task registered time safely
local function get_task_registered_time(reg)
    if not reg then return os.time() end
    
    local reg_time = reg.registered_time
    if reg_time and type(reg_time) == "number" and reg_time > 1000000000 then
        return reg_time
    end
    
    reg.registered_time = os.time()
    printf("[FA] Fixed invalid registered_time, new value: %s", tostring(reg.registered_time))
    return reg.registered_time
end

-- section prefix to monster squad type mapping
local SECTION_TO_MONSTER_TYPE = {
    ["boar"] = "monster_vegetarian",
    ["flesh"] = "monster_vegetarian",
    ["tushkano"] = "monster_vegetarian",
    ["tushkanchik"] = "monster_vegetarian",
    ["rat"] = "monster_vegetarian",
    
    ["dog"] = "monster_predatory",
    ["pseudodog"] = "monster_predatory",
    ["psy_dog"] = "monster_predatory",
    ["cat"] = "monster_predatory",
    ["chimera"] = "monster_predatory",
    ["lurker"] = "monster_predatory",
    
    ["zombie"] = "monster_zombied",
    ["snork"] = "monster_zombied",
    ["fracture"] = "monster_zombied",
    ["zombied"] = "monster_zombied",
    
    ["bloodsucker"] = "monster_special",
    ["controller"] = "monster_special",
    ["burer"] = "monster_special",
    ["poltergeist"] = "monster_special",
    ["pseudogiant"] = "monster_special",
    ["karlik"] = "monster_special",
    ["psysucker"] = "monster_special",
    ["gigant"] = "monster_special",
}

-- infer monster type from section name
local function infer_monster_type_from_section(section)
    if not section then return nil end
    
    -- first try: section starts with monster type
    for prefix, monster_type in pairs(SECTION_TO_MONSTER_TYPE) do
        if string.find(section, prefix, 1, true) == 1 then
            return monster_type
        end
    end
    
    -- second try: section contains monster type (for sections like "labx16_zombie_12", "gar_dog_5")
    for prefix, monster_type in pairs(SECTION_TO_MONSTER_TYPE) do
        if string.find(section, "_" .. prefix, 1, true) then
            return monster_type
        end
    end
    
    return nil
end

-- check if killed creature section matches required section
local function section_matches(kill_section, required_section, monster_type)
    if not required_section then return false end
    if not kill_section then return false end
    
    -- strip _day/_night suffix from monster types
    local function normalize_monster_type(mtype)
        if not mtype then return nil end
        local normalized = mtype:gsub("_day$", ""):gsub("_night$", "")
        return normalized
    end
    
    -- check if required_section is a monster category
    if string.find(required_section, "monster_", 1, true) == 1 then
        local required_normalized = normalize_monster_type(required_section)
        
        if monster_type then
            local kill_normalized = normalize_monster_type(monster_type)
            
            if kill_normalized == required_normalized then
                return true
            end
            if string.find(kill_normalized, required_normalized, 1, true) == 1 then
                return true
            end
            if string.find(required_normalized, kill_normalized, 1, true) == 1 then
                return true
            end
            return false
        end
        
        -- fallback: infer monster_type from section name
        local inferred_type = infer_monster_type_from_section(kill_section)
        if inferred_type then
            local inferred_normalized = normalize_monster_type(inferred_type)
            
            if inferred_normalized == required_normalized then
                return true
            end
            if string.find(inferred_normalized, required_normalized, 1, true) == 1 then
                return true
            end
            if string.find(required_normalized, inferred_normalized, 1, true) == 1 then
                return true
            end
        end
        
        return false
    end
    
    -- exact match
    if kill_section == required_section then return true end
    
    -- partial match: kill_section starts with required_section
    if string.find(kill_section, required_section, 1, true) == 1 then return true end
    
    return false
end

local function validate_bounty_kill(task_id)
    local target_id = nil
    
    local reg = _registered_tasks[task_id]
    if reg and reg.target_id then
        target_id = tonumber(reg.target_id) or reg.target_id
    end
    
    if not target_id then
        if axr_task_manager and axr_task_manager.bounties_by_id then
            target_id = axr_task_manager.bounties_by_id[task_id]
            if target_id then
                target_id = tonumber(target_id) or target_id
            end
        end
        if not target_id then
            local var = load_var(db.actor, task_id)
            if var then
                target_id = tonumber(var.target_id) or var.target_id
            end
        end
    end
    
    if not target_id then
        return false, "no_target"
    end
    
    printf("[FA] validate_bounty: task=%s target_id=%s (type=%s)", 
        tostring(task_id), tostring(target_id), type(target_id))
    
    local tracker = get_kill_tracker()
    if not tracker then
        return false, "no_tracker"
    end
    
    -- primary check: direct target kill
    if tracker.was_killed_by_player_or_companion then
        local killed = tracker.was_killed_by_player_or_companion(target_id)
        if killed then
            return true, "player_kill"
        end
    end
    
    -- fallback: target might be a squad ID, check if any squad member was killed
    if tracker.was_squad_member_killed_by_player then
        local squad_killed, member_id = tracker.was_squad_member_killed_by_player(target_id)
        if squad_killed then
            printf("[FA] validate_bounty: squad member %s killed for target %s", tostring(member_id), tostring(target_id))
            return true, "squad_member_kill"
        end
    end
    
    -- fallback: check if target is dead and player killed someone nearby recently
    -- this handles cases where the target_id doesn't match the kill record key
    if tracker.is_target_dead and tracker.is_target_dead(target_id) then
        local var = load_var(db.actor, task_id)
        if var then
            local squad_id = var.squad_id
            if squad_id and tracker.was_squad_member_killed_by_player then
                local squad_killed, member_id = tracker.was_squad_member_killed_by_player(tonumber(squad_id) or squad_id)
                if squad_killed then
                    printf("[FA] validate_bounty: target dead + squad member %s killed", tostring(member_id))
                    return true, "target_dead_squad_kill"
                end
            end
        end
    end
    
    -- time-correlation fallback: if the player killed anyone in the last few seconds,
    -- the game probably used a different ID than what we tracked.
    -- the fact that this bounty task is being evaluated means the game considers
    -- the target state changed - tight time window prevents false positives.
    if tracker.get_most_recent_player_kill then
        local recent_kill, recent_victim_id = tracker.get_most_recent_player_kill(8)
        if recent_kill and not recent_kill.is_monster then
            printf("[FA] validate_bounty: player killed NPC %s %ss ago -> time-correlation PASS",
                tostring(recent_victim_id), tostring(os.time() - recent_kill.time))
            return true, "time_correlation"
        end
    end
    
    return false, "not_player_kill"
end

local function validate_assault_kill(task_id)
    local smart_name = nil
    local smart_position = nil
    local smart_id = nil
    
    local reg = _registered_tasks[task_id]
    if reg and reg.smart_terrain then
        smart_name = reg.smart_terrain
    end
    
    -- get smart_id from task var
    local var = load_var(db.actor, task_id)
    if var and var.smart_id then
        smart_id = var.smart_id
        local smart_obj = alife_object(var.smart_id)
        if smart_obj then
            if not smart_name then
                smart_name = smart_obj:name()
            end
            if smart_obj.position then
                smart_position = smart_obj.position
                printf("[FA] validate_assault: got position from alife_object")
            end
        end
    end
    
    -- fallback: get smart position from SIMBOARD by name
    if smart_name and not smart_position and SIMBOARD then
        if SIMBOARD.smarts_by_names and SIMBOARD.smarts_by_names[smart_name] then
            local smart_data = SIMBOARD.smarts_by_names[smart_name]
            if smart_data and smart_data.smrt and smart_data.smrt.position then
                smart_position = smart_data.smrt.position
                printf("[FA] validate_assault: got position from smarts_by_names")
            end
        end
        
        -- try iterating smarts table
        if not smart_position and SIMBOARD.smarts then
            for id, smart_data in pairs(SIMBOARD.smarts) do
                if smart_data.smrt and smart_data.smrt:name() == smart_name then
                    if smart_data.smrt.position then
                        smart_position = smart_data.smrt.position
                        printf("[FA] validate_assault: got position from smarts iteration")
                    end
                    break
                end
            end
        end
    end
    
    -- fallback: get position by smart_id directly
    if smart_id and not smart_position and SIMBOARD and SIMBOARD.smarts and SIMBOARD.smarts[smart_id] then
        local smart_data = SIMBOARD.smarts[smart_id]
        if smart_data and smart_data.smrt and smart_data.smrt.position then
            smart_position = smart_data.smrt.position
            printf("[FA] validate_assault: got position from smarts by ID")
        end
    end
    
    -- can't determine task location, let vanilla handle it
    if not smart_name and not smart_position then
        return false, "no_smart_terrain"
    end
    
    printf("[FA] validate_assault: task=%s smart_terrain=%s smart_id=%s has_position=%s", 
        tostring(task_id), tostring(smart_name), tostring(smart_id), tostring(smart_position ~= nil))
    
    local task_registered_time = get_task_registered_time(reg)
    
    local tracker = get_kill_tracker()
    if tracker and tracker._player_kills then
        local player_kills_at_location = 0
        local player_kills_nearby = 0
        local total_kills_at_location = 0
        
        for victim_id, kill_data in pairs(tracker._player_kills) do
            -- only count kills after task was registered
            local kill_time = get_time_as_number(kill_data.time)
            if kill_time >= task_registered_time then
                local location_match = false
                local nearby_match = false
                
                -- exact smart terrain match
                if smart_name and kill_data.location == smart_name then
                    location_match = true
                end
                
                -- position-based match (within 150m)
                if smart_position and kill_data.position then
                    local kill_pos = kill_data.position
                    if type(kill_pos) == "table" and kill_pos.x then
                        local kill_vec = vector():set(kill_pos.x, kill_pos.y, kill_pos.z)
                        local dist = smart_position:distance_to(kill_vec)
                        if dist < 150 then
                            nearby_match = true
                            printf("[FA] validate_assault: kill within %.1fm of smart terrain", dist)
                        else
                            printf("[FA] validate_assault: kill too far - %.1fm from smart terrain", dist)
                        end
                    end
                end
                
                if location_match or nearby_match then
                    total_kills_at_location = total_kills_at_location + 1
                    if kill_data.is_player_kill or kill_data.is_companion_kill then
                        if location_match then
                            player_kills_at_location = player_kills_at_location + 1
                        end
                        if nearby_match then
                            player_kills_nearby = player_kills_nearby + 1
                        end
                        printf("[FA] validate_assault: matched kill - section=%s is_monster=%s location_match=%s nearby_match=%s", 
                            tostring(kill_data.section), tostring(kill_data.is_monster), tostring(location_match), tostring(nearby_match))
                    end
                end
            end
        end
        
        -- use the better count
        local player_kills = math.max(player_kills_at_location, player_kills_nearby)
        
        printf("[FA] validate_assault: player_kills=%s (at_location=%s nearby=%s) total=%s at %s", 
            tostring(player_kills), tostring(player_kills_at_location), tostring(player_kills_nearby), tostring(total_kills_at_location), tostring(smart_name))
        
        -- check against kill requirement (1=one, 2=half, 3=all)
        local kill_req = tonumber(get_mcm_config(nil, "kill_requirement")) or 1
        
        printf("[FA] validate_assault: kill_req=%s player_kills=%s", tostring(kill_req), tostring(player_kills))
        
        if player_kills > 0 then
            if kill_req == 1 then
                return true, "kills_at_location"
            elseif kill_req == 2 then
                if total_kills_at_location > 0 and player_kills >= (total_kills_at_location / 2) then
                    return true, "kills_at_location_half"
                elseif total_kills_at_location == 0 then
                    return true, "kills_at_location"
                end
            elseif kill_req == 3 then
                if total_kills_at_location > 0 and player_kills == total_kills_at_location then
                    return true, "kills_at_location_all"
                end
            else
                return true, "kills_at_location"
            end
        end
    end
    
    return false, "no_kills_at_location"
end

local function validate_defense_kill(task_id)
    local smart_name = nil
    
    local reg = _registered_tasks[task_id]
    if reg and reg.smart_terrain then
        smart_name = reg.smart_terrain
    end
    
    if not smart_name then
        local var = load_var(db.actor, task_id)
        if var and var.smart_id then
            local smart_obj = alife_object(var.smart_id)
            if smart_obj then
                smart_name = smart_obj:name()
            end
        end
    end
    
    if not smart_name then
        return false, "no_smart_terrain"
    end
    
    local task_registered_time = get_task_registered_time(reg)
    
    local player_faction = nil
    if db.actor then
        local se_actor = alife():actor()
        if se_actor then
            player_faction = se_actor:community()
        end
    end
    
    -- only count enemy NPC kills (not monsters)
    local tracker = get_kill_tracker()
    if tracker and tracker._player_kills then
        local enemy_kills = 0
        for victim_id, kill_data in pairs(tracker._player_kills) do
            local kill_time = get_time_as_number(kill_data.time)
            if kill_time >= task_registered_time then
                if (kill_data.is_player_kill or kill_data.is_companion_kill) 
                   and kill_data.location == smart_name 
                   and not kill_data.is_monster 
                   and kill_data.faction then
                    -- check if victim was enemy
                    if player_faction and game_relations.is_factions_enemies(kill_data.faction, player_faction) then
                        enemy_kills = enemy_kills + 1
                    end
                end
            end
        end
        
        if enemy_kills > 0 then
            return true, "enemy_kills_at_location"
        end
    end
    
    return false, "no_enemy_kills_at_location"
end

local function validate_mutant_hunt_kill(task_id)
    local tracker = get_kill_tracker()
    if not tracker or not tracker._player_kills then
        return false, "no_tracker"
    end
    
    local reg = _registered_tasks[task_id]
    local target_id = reg and reg.target_id
    local smart_name = reg and reg.smart_terrain
    local smart_position = nil
    
    -- try to get target_id and location from task var
    local var = load_var(db.actor, task_id)
    if var then
        if not target_id and var.target_id then
            target_id = var.target_id
        end
        
        -- get smart terrain
        if not smart_name and var.smart_id then
            local smart_obj = alife_object(var.smart_id)
            if smart_obj then
                smart_name = smart_obj:name()
                if smart_obj.position then
                    smart_position = smart_obj.position
                end
            end
        end
        
        if not smart_name and var.smart then
            if type(var.smart) == "string" then
                smart_name = var.smart
            elseif type(var.smart) == "number" then
                local smart_obj = alife_object(var.smart)
                if smart_obj then
                    smart_name = smart_obj:name()
                    if smart_obj.position then
                        smart_position = smart_obj.position
                    end
                end
            end
        end
        
        if not smart_name and var.target_smart then
            smart_name = var.target_smart
        end
    end
    
    -- try to get position from SIMBOARD
    if smart_name and not smart_position then
        if SIMBOARD and SIMBOARD.smarts_by_names and SIMBOARD.smarts_by_names[smart_name] then
            local smart = SIMBOARD.smarts_by_names[smart_name]
            if smart and smart.smrt and smart.smrt.position then
                smart_position = smart.smrt.position
            end
        end
    end
    
    -- Method A: specific target (bounty-style mutant task)
    if target_id then
        if tracker.was_killed_by_player_or_companion then
            local killed = tracker.was_killed_by_player_or_companion(target_id)
            if killed then
                printf("[FA] validate_mutant_hunt: specific target %s killed by player -> PASS", tostring(target_id))
                return true, "target_killed"
            end
        end
        return false, "target_not_player_kill"
    end
    
    printf("[FA] validate_mutant_hunt: task=%s, smart=%s, has_position=%s", 
        tostring(task_id), tostring(smart_name), tostring(smart_position ~= nil))
    
    -- Method B: location-based check with recent time window
    -- check if player killed ANY monster at location in last 5 minutes
    local current_time = os.time()
    local recent_window = 300  -- 5 minutes
    local kills_at_location = 0
    local kills_nearby = 0
    
    for victim_id, kill_data in pairs(tracker._player_kills) do
        if kill_data.is_monster and (kill_data.is_player_kill or kill_data.is_companion_kill) then
            local kill_time = get_time_as_number(kill_data.time)
            local time_diff = current_time - kill_time
            
            if time_diff <= recent_window then
                -- exact location match
                if smart_name and kill_data.location == smart_name then
                    kills_at_location = kills_at_location + 1
                end
                
                -- position-based match (within 150m)
                if smart_position and kill_data.position then
                    local kill_pos = kill_data.position
                    if type(kill_pos) == "table" and kill_pos.x then
                        local kill_vec = vector():set(kill_pos.x, kill_pos.y, kill_pos.z)
                        local dist = smart_position:distance_to(kill_vec)
                        if dist < 150 then
                            kills_nearby = kills_nearby + 1
                        end
                    end
                end
            end
        end
    end
    
    printf("[FA] validate_mutant_hunt: kills_at_location=%s, kills_nearby=%s (window=%ss)", 
        tostring(kills_at_location), tostring(kills_nearby), tostring(recent_window))
    
    if kills_at_location > 0 then
        return true, "kills_at_location"
    end
    
    if kills_nearby > 0 then
        return true, "kills_nearby"
    end
    
    -- Method C: fallback if we don't have location - any recent monster kill
    if not smart_name and not smart_position then
        local recent_monster_kills = 0
        for victim_id, kill_data in pairs(tracker._player_kills) do
            if kill_data.is_monster and (kill_data.is_player_kill or kill_data.is_companion_kill) then
                local kill_time = get_time_as_number(kill_data.time)
                local time_diff = current_time - kill_time
                if time_diff <= recent_window then
                    recent_monster_kills = recent_monster_kills + 1
                end
            end
        end
        
        if recent_monster_kills > 0 then
            printf("[FA] validate_mutant_hunt: no location info, but %s recent monster kills -> PASS (fallback)", tostring(recent_monster_kills))
            return true, "recent_monster_kills_no_location"
        end
    end
    
    return false, "no_kills_at_location"
end

-- ### AUTOCOMPLETE CHECK

local function is_in_list(list_str, task_id)
    if not list_str or list_str == "" or list_str == "none" then return false end
    for item in string.gmatch(list_str, "[^,]+") do
        item = item:match("^%s*(.-)%s*$")
        local item_task_id = item:match("^([^:]+)")
        if item_task_id and item_task_id == task_id then return true end
    end
    return false
end

-- get stage override from whitelist (e.g. "task_id:0")
local function get_whitelist_stage_override(list_str, task_id)
    if not list_str or list_str == "" or list_str == "none" then return nil end
    for item in string.gmatch(list_str, "[^,]+") do
        item = item:match("^%s*(.-)%s*$")
        local item_task_id, item_stage = item:match("^([^:]+):(%d+)$")
        if item_task_id and item_task_id == task_id and item_stage then
            return tonumber(item_stage)
        end
    end
    return nil
end

local function should_autocomplete(task_id, task_info)
    if _recently_processed[task_id] then
        return false, "recently_processed"
    end
    
    local stage = task_info.stage
    if not stage then return false, "no_stage" end
    
    -- Task giver death check - if task giver is dead, don't autocomplete
    -- The task should fail naturally when giver dies
    if task_info.task_giver_id then
        local se_giver = alife_object(task_info.task_giver_id)
        if not se_giver then
            return false, "giver_not_found"
        end
        -- Check if giver is alive (for NPCs)
        if se_giver.alive then
            local success, is_alive = pcall(function() return se_giver:alive() end)
            if success and not is_alive then
                return false, "giver_dead"
            end
        end
    end
    
    if HARDCODED_BLACKLIST[task_id] then
        return false, "blacklisted"
    end
    
    -- Check MCM blacklist (never autocomplete)
    local blacklist = (_cycle_config and _cycle_config.blacklist) or get_mcm_config(nil, "blacklist")
    if is_in_list(blacklist, task_id) then
        return false, "user_blacklisted"
    end
    
    -- Check if whitelisted (will bypass type check and kill validation, but NOT stage check)
    local whitelist = (_cycle_config and _cycle_config.whitelist) or get_mcm_config(nil, "whitelist")
    local is_whitelisted = is_in_list(whitelist, task_id)
    local whitelist_stage_override = get_whitelist_stage_override(whitelist, task_id)
    
    if not _task_cache[task_id] then
        local parsed = utils_data.parse_ini_section_to_array(task_manager.task_ini, task_id)
        if parsed then
            _task_cache[task_id] = parsed
            _task_cache_count = _task_cache_count + 1
        end
    end
    
    local tsk = _task_cache[task_id]
    if not tsk then return false, "no_task_def" end
    
    if tsk.storyline and tsk.storyline == "true" then
        return false, "storyline"
    end
    
    if not _registered_tasks[task_id] then
        register_task(task_id)
    end
    
    local target_functor = tsk.target_functor
    
    -- Whitelisted tasks bypass type check, others require valid functor and enabled type
    if not is_whitelisted then
        if not target_functor then return false, "no_functor" end
        
        if not is_task_type_enabled(target_functor, task_id) then
            return false, "type_disabled"
        end
    end
    
    local stage_complete = tonumber(tsk.stage_complete)
    if not stage_complete then return false, "no_complete_stage" end
    
    local current_stage = tonumber(stage)
    if not current_stage then return false, "stage_not_number" end
    
    -- Stage normalization for specific task types
    -- Spy extraction tasks need stage-1 adjustment for completion check
    local normalized_stage_complete = stage_complete
    if target_functor == "spy_task_target_functor" then
        normalized_stage_complete = stage_complete - 1
    end
    
    -- Whitelist stage override (e.g. "task_id:0" to complete at stage 0)
    if is_whitelisted and whitelist_stage_override then
        normalized_stage_complete = whitelist_stage_override
        printf("[FA] Using whitelist stage override for %s: %s", task_id, tostring(whitelist_stage_override))
    end
    
    if current_stage ~= normalized_stage_complete then
        return false, string.format("stage_mismatch(%d!=%d)", current_stage, normalized_stage_complete)
    end
    
    -- Whitelisted tasks bypass kill validation
    if is_whitelisted then
        return true, "whitelisted"
    end
    
    if get_mcm_config(nil, "require_player_kill") then
        local task_type = get_task_type(target_functor, task_id)
        printf("[FA] Task %s type=%s require_player_kill=true", tostring(task_id), tostring(task_type))
        
        if KILL_VALIDATION_TYPES[task_type] then
            if task_type == "bounty" then
                local valid, reason = validate_bounty_kill(task_id)
                printf("[FA] bounty validation: valid=" .. tostring(valid) .. " reason=" .. tostring(reason))
                if not valid then return false, "bounty_" .. reason end
            elseif task_type == "assault" then
                local valid, reason = validate_assault_kill(task_id)
                printf("[FA] assault validation: valid=" .. tostring(valid) .. " reason=" .. tostring(reason))
                if not valid then return false, "assault_" .. reason end
            elseif task_type == "defense" then
                local valid, reason = validate_defense_kill(task_id)
                printf("[FA] defense validation: valid=" .. tostring(valid) .. " reason=" .. tostring(reason))
                if not valid then return false, "defense_" .. reason end
            elseif task_type == "mutant_hunt" then
                local valid, reason = validate_mutant_hunt_kill(task_id)
                printf("[FA] mutant_hunt validation: valid=" .. tostring(valid) .. " reason=" .. tostring(reason))
                if not valid then return false, "mutant_" .. reason end
            end
        else
            printf("[FA] Task type %s not in KILL_VALIDATION_TYPES", tostring(task_type))
        end
    else
        printf("[FA] Task %s - require_player_kill is DISABLED", tostring(task_id))
    end
    
    return true, "passed"
end

-- ### POST-COMPLETION CLEANUP

local function post_completion_cleanup(task_id, target_functor)
    if not target_functor then return end
    
    -- spy extraction cleanup
    if target_functor == "spy_task_target_functor" then
        local var = load_var(db.actor, task_id)
        if not var then
            printf("[FA] post_completion_cleanup: no var for spy task %s", task_id)
            return
        end
        
        local spy_obj = var.spy_id and level.object_by_id(var.spy_id)
        if not spy_obj then
            printf("[FA] post_completion_cleanup: spy_obj is nil for task %s", task_id)
        end
        
        local se_squad = var.squad_id and alife_object(var.squad_id)
        if not se_squad then
            printf("[FA] post_completion_cleanup: se_squad is nil for task %s", task_id)
            return
        end
        
        if fair_autocomplete_utils and fair_autocomplete_utils.stop_talk_squad then
            fair_autocomplete_utils.stop_talk_squad(se_squad)
        end
        
        se_squad.scripted_target = nil
        se_squad.current_action = nil
        
        if axr_companions and axr_companions.companion_squads then
            axr_companions.companion_squads[se_squad.id] = nil
        end
        
        if spy_obj then
            pcall(function()
                xr_logic.restore_scheme_and_logic(spy_obj)
                spy_obj:disable_info_portion("npcx_is_companion")
                spy_obj:disable_info_portion("npcx_beh_cannot_dismiss")
            end)
        end
        
        local se_spy = var.spy_id and alife_object(var.spy_id)
        if se_spy then
            local sname = se_spy:name()
            pcall(function()
                se_save_var(var.spy_id, sname, "companion", nil)
                se_save_var(var.spy_id, sname, "companion_cannot_dismiss", nil) 
                se_save_var(var.spy_id, sname, "companion_cannot_teleport", nil)
            end)
        end
        
        pcall(function()
            SIMBOARD:remove_squad(se_squad)
        end)
        
        printf("[FA] Spy task cleanup complete for %s", task_id)
        return
    end
    
    -- hostage task cleanup
    if target_functor == "simulation_task_target" then
        local var = load_var(db.actor, task_id)
        if var and var.squad_id then
            local se_squad = alife_object(var.squad_id)
            if se_squad then
                if fair_autocomplete_utils and fair_autocomplete_utils.stop_talk_squad then
                    fair_autocomplete_utils.stop_talk_squad(se_squad)
                end
            end
        end
        return
    end
end

-- ### MAIN LOOP

local _cycle_config = nil

local function get_cycle_config()
    if not _cycle_config then
        _cycle_config = {
            enable = get_mcm_config(nil, "enable"),
            enable_autocomplete = get_mcm_config(nil, "enable_autocomplete"),
            pda_check = get_mcm_config(nil, "pda_check"),
            debug = get_mcm_config(nil, "debug"),
            require_player_kill = get_mcm_config(nil, "require_player_kill"),
            cancel_if_stolen = get_mcm_config(nil, "cancel_if_stolen"),
            compensate_item_rewards = get_mcm_config(nil, "compensate_item_rewards"),
            kill_requirement = get_mcm_config(nil, "kill_requirement") or 1,
            whitelist = get_mcm_config(nil, "whitelist"),
            blacklist = get_mcm_config(nil, "blacklist"),
        }
    end
    return _cycle_config
end

local function do_autocompletion()
    if not _mod_ready then return end
    
    -- Periodic cleanup (prevent memory growth)
    cleanup_task_cache()
    
    -- Cache MCM config for this cycle (performance)
    _cycle_config = nil  -- Reset cache
    local cfg = get_cycle_config()
    
    if not cfg.enable then return end
    
    -- PDA check (was missing!)
    if cfg.pda_check then
        if not db.actor then return end
        local has_pda = false
        if fair_autocomplete_utils and fair_autocomplete_utils.has_pda then
            has_pda = fair_autocomplete_utils.has_pda(db.actor)
        else
            -- Fallback PDA check
            has_pda = db.actor:object("device_pda_1") or db.actor:object("device_pda_2") 
                   or db.actor:object("device_pda_3") or db.actor:object("device_pda_milspec")
        end
        if not has_pda then return end
    end
    
    local tm = task_manager.get_task_manager()
    if not tm or not tm.task_info then return end
    
    local tasks_to_complete = {}
    local tasks_to_cancel = {}
    
    for task_id, task_info in pairs(tm.task_info) do
        if task_id and task_info then
            -- Quick pre-filter: skip tasks not at completion stage (performance)
            local stage = task_info.stage
            if stage and stage >= 0 and stage <= 20 then
                local ok, err = pcall(function()
                    local should, reason = should_autocomplete(task_id, task_info)
                    
                    if cfg.debug then
                        printf("[FA] Task %s: should=%s, reason=%s", 
                            tostring(task_id), tostring(should), tostring(reason))
                    end
                    
                    if should then
                        -- only autocomplete if enabled
                        if cfg.enable_autocomplete then
                            local target_functor = nil
                            if _task_cache[task_id] then
                                target_functor = _task_cache[task_id].target_functor
                            end
                            table.insert(tasks_to_complete, {
                                id = task_id,
                                giver_id = task_info.task_giver_id,
                                target_functor = target_functor
                            })
                        end
                    elseif reason and (reason:find("no_kills") or reason:find("not_player_kill") or reason:find("no_recent")) then
                        printf("[FA] Adding to cancel list: %s reason=%s", tostring(task_id), tostring(reason))
                        table.insert(tasks_to_cancel, {
                            id = task_id,
                            giver_id = task_info.task_giver_id,
                            reason = reason
                        })
                    end
                end)
                if not ok then
                    printf("![FA] Error checking task %s: %s", tostring(task_id), tostring(err))
                end
            end
        end
    end
    
    for _, task_data in ipairs(tasks_to_complete) do
        printf("[FA] AUTOCOMPLETING: %s", task_data.id)
        
        -- Mark as recently processed BEFORE completing (prevents duplicates)
        _recently_processed[task_data.id] = os.time()
        
        -- Mark as being autocompleted (for item compensation in task_callback)
        _tasks_being_autocompleted[task_data.id] = true
        
        pcall(function()
            -- Post-completion cleanup for specific task types (spy, hostage)
            -- Must be done BEFORE completing the task
            post_completion_cleanup(task_data.id, task_data.target_functor)
            
            -- Send completion PDA message (like original mod)
            show_completion_message(task_data.id, task_data.giver_id)
            
            -- Complete the task
            -- Item compensation is handled by task_callback hook
            tm:set_task_completed(task_data.id)
        end)
        
        -- Note: _tasks_being_autocompleted flag is cleared in task_callback after compensation
        
        unregister_task(task_data.id)
    end
    
    -- Always log cancel list size for debugging
    if #tasks_to_cancel > 0 then
        printf("[FA] Tasks to cancel: %s, cancel_if_stolen=%s", tostring(#tasks_to_cancel), tostring(cfg.cancel_if_stolen))
    end
    
    if cfg.cancel_if_stolen then
        for _, task_data in ipairs(tasks_to_cancel) do
            printf("[FA] CANCELLING (stolen): %s - %s", tostring(task_data.id), tostring(task_data.reason))
            
            -- Mark as recently processed BEFORE cancelling (prevents duplicates)
            _recently_processed[task_data.id] = os.time()
            
            pcall(function()
                -- Stop any ongoing dialog with task-related NPCs (CTD prevention)
                local var = load_var(db.actor, task_data.id)
                if var then
                    local squad_id = var.squad_id or var.target_id
                    if squad_id then
                        local se_squad = alife_object(squad_id)
                        if se_squad and se_squad.squad_members and fair_autocomplete_utils then
                            fair_autocomplete_utils.stop_talk_squad(se_squad)
                        end
                    end
                end
                
                -- Use set_task_cancelled - cancels without reputation loss
                tm:set_task_cancelled(task_data.id)
                
                show_stolen_message(task_data.id, task_data.giver_id)
            end)
            unregister_task(task_data.id)
        end
    else
        if #tasks_to_cancel > 0 then
            printf("[FA] cancel_if_stolen is disabled, not cancelling tasks")
        end
    end
end

-- ### INITIALIZATION

function actor_on_first_update()
    printf("[FA] actor_on_first_update - mod ready!")
    _mod_ready = true
    
    local interval = get_mcm_config(nil, "check_interval") or 2.0
    interval = math.max(0.5, tonumber(interval) or 2.0)
    
    CreateTimeEvent("fair_autocomplete", "main_loop", interval, function()
        pcall(do_autocompletion)
        local new_interval = get_mcm_config(nil, "check_interval") or 2.0
        new_interval = math.max(0.5, tonumber(new_interval) or 2.0)
        ResetTimeEvent("fair_autocomplete", "main_loop", new_interval)
        return false
    end)
end

function on_game_start()
    printf("[FA] on_game_start called")
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
end

function save_state(m_data)
    m_data.fa_registered_tasks = _registered_tasks
end

function load_state(m_data)
    _task_cache = {}
    _task_cache_count = 0
    _registered_tasks = m_data.fa_registered_tasks or {}
    _recently_processed = {}
    _task_compensation_prices = {}
    _tasks_being_autocompleted = {}
    _utils = nil
    _kill_tracker = nil
    _cycle_config = nil
    
    -- fix old registered tasks without valid timestamp
    local current_time = os.time()
    for task_id, reg_data in pairs(_registered_tasks) do
        local rt = reg_data.registered_time
        if not rt or type(rt) ~= "number" or rt < 1000000000 then
            reg_data.registered_time = current_time
            printf("[FA] Fixed registered_time for task: %s (was: %s)", tostring(task_id), tostring(rt))
        end
    end
    
    _mod_ready = true
    
    -- recreate time event after load
    local interval = 2.0
    if fair_autocomplete_mcm and fair_autocomplete_mcm.get_config then
        interval = fair_autocomplete_mcm.get_config(nil, "check_interval") or 2.0
    end
    interval = math.max(0.5, tonumber(interval) or 2.0)
    
    RemoveTimeEvent("fair_autocomplete", "main_loop")
    CreateTimeEvent("fair_autocomplete", "main_loop", interval, function()
        pcall(do_autocompletion)
        local new_interval = 2.0
        if fair_autocomplete_mcm and fair_autocomplete_mcm.get_config then
            new_interval = fair_autocomplete_mcm.get_config(nil, "check_interval") or 2.0
        end
        new_interval = math.max(0.5, tonumber(new_interval) or 2.0)
        ResetTimeEvent("fair_autocomplete", "main_loop", new_interval)
        return false
    end)
    
    printf("[FA] load_state complete - mod ready")
end

-- ### MONKEYPATCHES

-- stop talking before squad removal (CTD prevention)
local _original_remove_squad = nil
if sim_board and sim_board.simulation_board and sim_board.simulation_board.remove_squad then
    _original_remove_squad = sim_board.simulation_board.remove_squad
    
    -- Override with safe version that stops dialog first
    sim_board.simulation_board.remove_squad = function(self, squad)
        -- Stop any ongoing dialog with squad members before removal
        if squad and fair_autocomplete_utils and fair_autocomplete_utils.stop_talk_squad then
            pcall(function()
                fair_autocomplete_utils.stop_talk_squad(squad)
            end)
        end
        
        return _original_remove_squad(self, squad)
    end
    
    printf("[FA] Monkeypatched sim_board.remove_squad for CTD prevention")
end

-- item compensation (replaces items with money for autocompleted tasks)
task_manager_task_callback = task_manager.task_callback
task_manager.task_callback = function(tsk, stage)
    local tsk_id = tsk:get_id()
    
    printf("[FA] task_callback fired: task=%s stage=%s autocomplete_flag=%s", 
        tostring(tsk_id), tostring(stage), tostring(_tasks_being_autocompleted[tsk_id] or false))
    
    if not _tasks_being_autocompleted[tsk_id] then
        task_manager_task_callback(tsk, stage)
        return
    end
    
    _tasks_being_autocompleted[tsk_id] = nil
    
    if not get_mcm_config(nil, "enable") or not get_mcm_config(nil, "compensate_item_rewards") then
        printf("[FA] task_callback: compensation disabled in MCM")
        task_manager_task_callback(tsk, stage)
        return
    end
    
    if stage ~= task.completed then
        printf("[FA] task_callback: not completed stage")
        task_manager_task_callback(tsk, stage)
        return
    end
    
    local rtask = task_manager.get_task_manager().task_info[tsk_id]
    if not rtask or not rtask.on_complete or not rtask.on_complete[1] or not rtask.on_complete[1][3] then
        printf("[FA] task_callback: no on_complete data")
        task_manager_task_callback(tsk, stage)
        return
    end
    
    local compensation = _task_compensation_prices[tsk_id]
    if not compensation then
        printf("[FA] task_callback: calculating compensation for %s", tostring(tsk_id))
        compensation = calculate_task_compensation(rtask.on_complete[1][3])
        _task_compensation_prices[tsk_id] = compensation
    end
    
    if not compensation or not compensation.rewards then
        printf("[FA] task_callback: no compensation calculated")
        task_manager_task_callback(tsk, stage)
        return
    end
    
    printf("[FA] Applying item compensation for task %s: %s-%s RU", tsk_id, tostring(compensation.min or 0), tostring(compensation.max or 0))
    
    -- save original rewards in case callback errors
    local original_rewards = rtask.on_complete[1][3]
    rtask.on_complete[1][3] = compensation.rewards
    
    local ok, err = pcall(task_manager_task_callback, tsk, stage)
    if not ok then
        printf("![FA] task_callback error, restoring original rewards: %s", tostring(err))
        rtask.on_complete[1][3] = original_rewards
        pcall(task_manager_task_callback, tsk, stage)
    end
end

printf("[FA] Monkeypatched task_manager.task_callback for item compensation")

printf("[FA] Core script loaded successfully")
